`oop overview`
=

В `python` всё является объектами - экземплярами каких-либо классов, даже сами классы, которые являются объектами - экземплярами метаклассов.
Главным метаклассом является класс `type`, который является абстракцией понятия типа данных.

В `python` - тип данных и класс - это синонимы.


Атрибуты класса являются общими для самого класса и всех его экземпляров. Их изменение отображается на все соответствующие объекты.
Атрибуты экземпляров принадлежат конкретному экземпляру и их изменение никак не влияет на соответствующие атрибуты других экземпляров данного класа.

`bound method`
=

Есть класс с методом `foo`. Когда мы создаём новый экземпляр, то к нему в атрибуты дбавляется связанный метод `foo`, который длегирует
свой вызов функции, определённой в классе и в качестве аргумента передаёт ей переменную, которая ссылается на этот экземпляр.

```
>>> class Person:
...     def __init__(self, name):
...         self.name = name
...         
...     def foo(self):
...         print(f"My name is {self.name}")
...          
>>> john = Person("John")
>>> Person.foo
<function Person.foo at 0x7fca6894de18>
>>> dir(john)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__',
 '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '
__str__', '__subclasshook__', '__weakref__', 'foo', 'name']
>>> 
>>> john.foo
<bound method Person.foo of <__main__.Person object at 0x7fca689b9d68>>
>>> 
>>> Person.foo(john)
My name is John

```
Если у класса определён метод - то в его пространстве имён этому методу соответствует самая обычная функция.
При инстанцировании данного класса питон автоматически во всех экземплярах, для каждой функции атрибута, строит соответствующий ей
объект класса `bound method`. Этот объект-етод знает какому он объекту принадлежит и какой функции соответствует. 
И каждый раз когда мы вызывем этот метод - он просто берёт и вызывает соответствующую функцию в атрибутах(словаре) класса и передаёт
её в качестве первого параметра ссылку на сам этот объект, у которого вызывался этот метод.


- Методы класса походи на обычные методы, но относятся к самому классу как к объекту - экземпляру метакласса.
- Обычные методы - принадлежат экземплярам класса.
- Статические методы - их могут использовать как экземпляры класса так и сами классы.

```
class Foo:
    class_attribute = 42

    def __init__(self):
        self.instance_attribute = 42


    @staticmethod
    def static_method():
        print("i am static")


    @classmethod
    def class_method(cls):
        print()
```

`object`
=

В питоне до версии 2.2 объектная истема была ограничена, к примеру нельзя было наледовать от базовых классов(от int, dict и тд).
Начиная с 2.2 объектную систему переработали и в целях совместимости с существующим кодом оставили старую систему.
Таким образм начиная с 2.2 до 2.7 в питоне существует две объектные системы, old-class style - new-class style.

Для создания класса нового стиля требовалось явно наследовать от класса `object`.

В python3 все классы - классы нового типа и неявно наследуются от `object` - от класса, являющимся базовым для всех классов.
