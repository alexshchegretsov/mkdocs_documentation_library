```
import socket

# сокет это пара domain:port, через которые
# осуществляется взаимодействие между двумя субъектами
# между клиентом и сервером

# описание сервера - того, кто будет обслуживать запросы клиента
# AF_INET - ipv4 - ip-протокол 4-ой версии
# SOCK_STREAM - поддержка протокола TCP
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Есл мы вдруг прервём работу скрипта, то может получиться так, что
# мой порт будет занят, и ОС не позволит его повторно использовать
# пока не пройдёт TimeOut - в ubuntu это примерно 3 мин
# этот таймаут используется для того, чтобы те данные, которые находятся в пути
# дошли до своего адресата, и, для того чтобы мы могли повторно использовать
# тот же номер порта нашего сокета, мы должны определить следующие опции
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# указываем к какому домену и порту привязываем сокет
server_socket.bind(("localhost", 5000))

# нужно указать сокетному серверу, чтобы он начал прослушивать входящий буфер
# на предмет входящих подключений
server_socket.listen()

# отношения между клиентом и сервером - это всегда длящиеся отношения
# и мы не знаем сколько времени это взаимодействие займёт
# поэтому как правило используется бесконечный цикл(while True)
while True:
    print("before .accept()")
    # наш канал общения - это своего рода двухсторонний мостик между двумя субъектами
    # между сервером и клиентом
    # серверную сторону мы описали, теперь нам нужен клиентский сокет
    # у серверного сокета есть метод accept(), который принимает входящие подключения,
    # читает данные из входящего буфера, и если на вход пришло что-то(какоето клиентское подключение) -
    # accept() возвращает нам кортеж из двух элементов:
    # 1. копию слушающего сокета, т.к. слушающий сокет, приняв соединение, создаёт свою копию и направляет подключение в новый сокет,
    # а сам продолжает слушать порт на предмет входящих соединений 
    # 2. адресс
    # при .accept() скрипт замораживается и ждёт входящего подключения
    # другими словами .accept() - блокирующая функция,
    # .accept() блокирует выполнение нашей программы
    # впринципе любые функции является блокирующими операциями
    # они блокируют выполнение программы до тех пор, пока не закончат свою работу
    # и не вернут результат, а вместе с результатом возвращается
    # контроль выполнения программы в то место, откуда произошёл вызов функции
    client_socket, addr = server_socket.accept()
    print("connection from:", addr)

    # входящее подключение мы приняли
    # теперь мы должны дождаться от клиента какого-то сообщения
    # опять бесконечный цикл
    while True:
        # обращаемся к клиентскому сокету, который от пользователя будет принимать какое-то сообщение
        # указываем размер буфера для этого сообщения
        request = client_socket.recv(4096)
        # опишем условие выхода из цикла
        if not request:
            break
        else:
            # создаём и отправляем ответ в клиентский сокет
            response = b"Hello man\n"
            client_socket.sendall(response)

    print("Outside inner loop")
    client_socket.close()

# в этом примере, чтобы принять второе подключение - нам нужно было выйти из
# внутреннего цикла "while" - чтобы попасть на вторую итерацию внешнего цикла "while",
# принять новое подключение от второго клиента, и пока первый клиент думает, что ввести -
# снова попасть во внутренний цикл "while" и обработать запрос второго клиента.
# тоесть возникает проблема с тем, что нужно каким-то образом передавать контроль управления программой,
# каким-то образом приостанавливать, запускать функции при наступлении определённых событий
# когда входящий буфер заполняется или исходящий буфер очищается,
# когда мы читаем что-то из буферов, или пишем что-то в буферы
#
# для решения этих задач нужны два ингридиента:
# 1. возможность передавать контроль управления программой куда-то
# 2. некоторый код(менеджер), который бы управлял всем процессом, тоесть
# тот код, куда и передаётся управление программой в период ожидания, пока клиент что-то там напишет,
# т.е. код, который поможет решить что нам делать дальше и кому отвечать
# и вот этот кусок кода обычно называют событийным циклом, или event loop
#
# асинхронный код можно писать без использования сторонних библиотек 3-мя способами:
# 1. при помощи callback'ов
# 2. при помощи генераторов и корутин
# 3. при помощи async/await


```
