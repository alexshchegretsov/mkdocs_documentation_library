`postgreSQL`
=
Транзакция - некая неделимая, логически-связанная часть работы, от которой ожидают выполнение четырёх свойcтв(ACID):

- `атомарность` - всё или ничего. Транзакция либо выполняется вся, либо не выполняется ничего.
- `согласованность` - ограничения целостности и пользовательские ограничения.
- `изоляция` - влияние параллельных процессов. Если в базе данных происходят параллельные процессы - то они не олжны друг другу мешать.
- `долговечность` - как только мы зафиксировали транзакцию - это гарантирует сохранность данных, даже после сбоя.

`# атомарность, согласованность`

Основное свойство - это `согласованность`. Это то ради чего транзакции существуют, т.е мы хотим, что бы данные которые хранятся
в базе - они были всегда корректны, и, что бы мы, даже если захотим - не могли эту корректность, или согласованность нарушить.
Тоесть у нас есть данные, они удовлетворяют каким-то ограничениям, они согласованы, и дальше эти данные мы можем менять
только на уровне транзакций. Мы выполняем какую-нибудь транзакцию, которая переводит базу данных из одного согласованного состояния - в другое.
А поскольку у нас есть свойство атомарности(т.е. мы не можем выполнить половину транзакции) - то у нас данные всегда
переходят из одного согласованного состояния в другое согласованное.

`# изоляция`

Если у нас транзакции идут одна за другой - то всё хорошо. Но если транзакции выполняются параллельно, то есть возможность того, что
одна транзакция увидит изменения другой транзакции, которые ещё не зафиксированы и что-то в таком духе. Соответственно
нужно выбрать правильный уровень изоляции, что бы такого не происходило.

`commit` - зафиксировать транзакцию.
`rollback` - отменить транзакцию.


В самой базе postgres есть главный процесс - `postmaster`, фоновые процессы, и процессы обслуживающие, которые обслуживают клиентов.
Когда у нас появляется клиент - он обращается к postgres на его порт - `postmaster` этот порт слушает, и когда он видит, что кто-то к нему идёт,
он порождает обслуживающий процесс(backend), и переключает клиента на этот процесс - дальше клиент общается со своим процессом, взаимодействую
друг с другом как раз по протоколу, который способен реализовать драйвер к базе postgres.

- Протокол позволяет клиентам подключаться к серверу, выполнять запросы и управлять транзакциями.
- Каждый клиент обслуживается своим процессом. Если клиентов много, или есть клиенты, которые подключаются и 
тут же отключаются(порождая тяжеловесные процессы, разбор запроса, а оказывается всё зря так как клиент отключился) - то создаётся пул соединений.
- Данные хрянятся в файлах, обращение происходит через операционную систему
- Кэширование как в локальной памяти(каталог, разобранные запросы) так и в общей(буферный кэш).



