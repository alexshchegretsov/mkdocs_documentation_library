Идея алгоритма заключается в том, чтобы за каждую итерацию внешнего цикла находить 
минимальный элемент списка и вставлять его вначало.
[2, 4, 5, 0] -> [0, 4, 5, 2] -> [0, 2, 5, 4] -> [0, 2, 4, 5]

```
Стартуем со второго элемента, ищем минимальный сравнивая каждый с первым,
найдя минимальный -  свап с первым, 

def selection_sort(a: list) -> list:
    # определяем длину списка
    length = len(a)
    # диапазон меньше на 1, зазор для внутреннего цикла при i+1
    # внутренний цикл всегда стартует с i+1 
    # поэтому когда i будет предпоследним, j - будет последним
    for i in range(length-1):
        # предполагаем что минимальный элемент находится под индексом i
        min_id = i
        # стартуем с i+1 и ищем минимальный элемент, сравнивая остальные числа с a[min_id]
        for j in range(i+1, length):
            if a[min_id] > a[j]:
                min_id = i
        if min_id != i:
            a[i], a[min_id] = a[min_id], a[i]
    return a
``` 
- на 1ой итерации - n-1 сравнение
- на 2ой итерации - n-2 сравнение
- на 3ей итерации - n-3 сравнение
- и на n-1ой итерации мы сделаем 1 сравнение(предпоследнее с последним)
- кол-во сравнений (1 + 2 + 3 + ... + n-3 + n-2 + n-1)
- формула суммы n-членов арифметической прогрессии ((a1 + an)/2)*n
- a1 = 1, an = n-1 --> ((1 + n-1)/2)*(n-1) = (n*(n-1))/2 = (n**2 - n)/2
- O(n**2)
