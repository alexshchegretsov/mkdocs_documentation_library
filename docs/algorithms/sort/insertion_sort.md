`insertion sort`
=

Идея алгоритма в том, чтобы начинать со второго элемента
тоесть внешний цикл `for i in range(1, length)` - здесь нам нужен последний элемент.
Цикл while
Берём второй элемент и сравниваем его с предыдущим - если наш текущий элемент
меньше чем предыдущий и `i > 0` - то мы их меняем местами и декрементируем i.


```
def insertion(a: list) -> list:
    length = len(a)
    for i in range(1, length):
        while a[i] < a[i-1] and i > 0:
            a[i], a[i-1] = a[i-1], a[i]
            i -= 1
    return a

```

- на 1ой итерации мы можем сделать 1 перестановку
- на 2ой - 2 перестановки
- на n - n-1 перестановку
- опять формула суммы n-членов арифметической прогрессии (1 + 2 + 3 + ... + n-2 + n-1)
- ((1 + (n-1))/2)*(n-1)
- худший случай O(n**2)
- лучший Omega(n) - когда массив отсортирован - мы сделаем n-1 сравнение
