`bubble sort`
=

Идея алгоритма очень проста.
Внешний цикл не участвует в индексации, он стартует с (1, length) и уменьшает 
правую границу внешнего цикла на 1 каждый раз.

Вся работа ведётся во внутреннем цикле.
каждый раз мы стартуем с начала списка, и за каждую
итерацию внешнего цикла находим максимальный элемент - он становится справа
и считается отсортированным, размер массива уменьшается на 1.

```

def bubble_sort(a: list) -> list:
    length = len(a)
    # будет уменьшать диапазон внутреннего цикла
    for i in range(1, length):
        swapped = False
        for j in range(length-i):
            if a[j] > a[j+1]:
                swapped = True
                a[j], a[j+1] = a[j+1], a[j]
        if not swapped:
            break
    return a


```
- худший случай когда массив в порядке убывания
- на 1ой итерации - n-1 перестановок
- на 2ой итерации - n-2 перестановок
- на n-1ой итерации - 1 перестановка
- опять арифметическая прогрессия ((1 + (n-1))/2)*(n-1)
- O(n**2)
- лучший случай когда массив отсортирован, нам нужно сделать только n проверок - сработает флаг swapped
- Omega(n)
