`ABSOLUTE_URL_OVERRIDE`
==

Словарь, содержащий ключи в формате "app_label.model_name" к функциям, которые принимает объект указанной модели и возвращает ее URL. 
Эта настройка позволяет переопределить методы get_absolute_url() модели для конкретной установки проекта. 
Название модели должно быть в нижнем регистре не смотря на реальное название класса модели.

```
ABSOLUTE_URL_OVERRIDES = {
    'blogs.weblog': lambda x: f"/blogs/{x.slug}/",
    'news.story': lambda x: f"/stories/{x.pub_year}/{x.slug}/",
}


```
_Общая интуиция_

Для модели часто полезно «знать» ее URL. Это особенно верно для сайтов, которые следуют принципам RESTful, 
где любой объект на сайте должен иметь один и только один канонический URL.
Также полезно хранить логику URL в одном и том же месте, насколько это возможно. Шаблонный тег Django {% url %} и 
функция reverse () решают несколько другую проблему - они разрешают URL-адреса к представлениям, 
а не к отдельным моделям, и рассматривают URLconf как единственную точку истинности для URL-адресов. 
{% url myapp.views.profile user.id%} не так прагматичен, как {{user.get_absolute_url}}, так как если мы изменим представление профиля, 
приняв имя пользователя вместо идентификатора пользователя в URL, мы придется вернуться и обновить все наши шаблоны.
Возможность получить URL для модели также полезна вне системы шаблонов. 
Все модули admin, syndication и sitemaps Django пытаются получить URL для модели в различных точках, используя метод get_absolute_url.
Текущий механизм информирования модели об их URL-адресе - полустандартизированный метод get_absolute_url. 
Если вы предоставите этот метод в своем классе модели, ряд различных мест в Django будет использовать его для создания URL-адресов. 
Вы также можете переопределить это, используя settings.ABSOLUTE_URL_OVERRIDES.


`ADMINS`
==

По умолчанию: [] (Пустой список)

Кортеж содержит список людей, которые будут получать уведомления об ошибках. 
Если DEBUG=False и приложение вызывает исключение, Django отравит e-mail с информацией об исключении. 
Каждый элемент кортежа должен быть кортежем формата (Полное имя, e-mail). 

Заметим, что Django отправит email всем при возникновении ошибки.
Например:

```
[('John', 'john@example.com'), ('Mary', 'mary@example.com')]

```

`ALLOWED_HOSTS`
==

Список хостов/доменов, для которых может работать текущий сайт.

Это сделано для безопасности, чтобы обезопасить от внедрения в куки или письма для сброса пароля ссылок на сторонний сайт 
подменив HTTP заголовок Host, что возможно при многих, казалось бы безопасных, конфигурациях сервера.
Список может содержать полное имя домена (например 'www.example.com'), тогда значение заголовка Host будет сравниваться с этим значением (проверка без учета регистра и порта). Значение для проверки и поддоменов: '.example.com', удовлетворяет example.com, www.example.com``и всем поддоменам ``example.com. Значение '*' принимает все значения, в этом случае вы сами должны проверять заголовок Host (возможно в middleware, при этом укажите его в MIDDLEWARE_CLASSES).
Django также позволяет использовать полное доменное имя (FQDN). Некоторые браузеры добавляют точку в конце заголовка Host, которую Django удаляет перед проверкой хоста.
Если заголовок Host (или X-Forwarded-Host при USE_X_FORWARDED_HOST) не совпадает ни с одним значением, метод django.http.HttpRequest.get_host() вызовет исключение SuspiciousOperation.
При DEBUG равном True и при выполнении тестов проверка отключена. Проверка обычно нужна только на боевом сервере.
Проверка выполняется только в методе get_host(), если вы используете значение заголовка Host непосредственно из request.META, проверка не будет выполнена.

Для бoевого сервера нужно прописывать все варианты. Например:

```
ALLOWED_HOSTS = ['https://spb-tut.ru', 'www.spb-tut.ru', 'spb-tut.ru']
```

`APPEND_SLASH`
==

По умолчанию: True

Если равна True и запрошенный URL не удовлетворяет ни одному URL-шаблону из URLconf и URL не заканчивается косой чертой, 
Django верен HTTP перенаправление на этот же URL но с косой чертой в конце. 
Заметим что такое перенаправление может привести к потере всех данных при POST запросе.
Настройка APPEND_SLASH используется только вместе с CommonMiddleware .

`CACHES`
==

Словарь, содержащий настройки для всех механизмов кэширования Django, используемых в проекте. 

Содержит имена кэшей и словарь с настройками для каждого.

```
{
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
    }
}


```

`BACKEND`
==

По умолчанию: '' (Пустая строка)

Бэкенд кэширования, который используется. 
Django предоставляет следующие бэкенды:

```
'django.core.cache.backends.db.DatabaseCache'
'django.core.cache.backends.dummy.DummyCache'
'django.core.cache.backends.filebased.FileBasedCache'
'django.core.cache.backends.locmem.LocMemCache'
'django.core.cache.backends.memcached.MemcachedCache'
'django.core.cache.backends.memcached.PyLibMCCache'
```
Вы можете использовать сторонние бэкэнды указав в BACKEND путь для импорта класса (например, mypackage.backends.whatever.WhateverCache).

`KEY_FUNCTION`
==

Путь для импорта функции, которая создает конечный ключ кэша из префикса, версии кэша и значения ключа. 

Функция по умолчанию выглядит следующим образом:

```
def make_key(key, key_prefix, version):
    return ':'.join([key_prefix, str(version), key])
```

Вы можете использовать любую функцию, которая принимает аналогичные аргументы.


`KEY_PREFIX`
==

По умолчанию: '' (Пустая строка)

Строка, которая будет автоматически добавлена (по умолчанию в начало) ко всем ключам кэша используемых Django.


`LOCATION`
==

По умолчанию: '' (Пустая строка)

Расположение используемого кэша. 
Это может быть путь к каталогу при кэшировании в файле, название хоста и порт для memcache, 
или просто уникальное название для кэширования в памяти. Например:

```
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}
```

`OPTIONS`
=

По умолчанию: None

Дополнительные параметры для бэкенда кэширования. Доступные параметры зависят от используемого бэкенда кэширования.

[о настройках кеширования с сайта djbook.ru](https://djbook.ru/rel1.9/topics/cache.html)

[о настройках кеширования с djangoproject](https://docs.djangoproject.com/en/2.2/topics/cache/#cache-arguments)

`TIMEOUT`
==

По умолчанию: 300

Время в секундах, после которого запись в кэше удаляется. Если значение равно None - срок хранения кеша не ограничен.


`VERSION`
==

По умолчанию: 1

Значения по умолчанию для версии кэша.


При изменении работающего кода, который использует закэшированные значения, может потребоваться сброс всех закэшированных данных. 
Простым способом является отчистка всего кэша, но это может привести к потере закэшированных данных, которые всё ещё верны и полезны.
Django предоставляет отличный способ выделения отдельных значений в кэше. 
Система кэширования Django обладает глобальным идентификатором версии, определённым в параметре кэша VERSION. 
Значение этого параметра автоматически объединяется с префиксом кэша и пользователем, которые предоставил ключ, 
получая итоговый ключ для обращения к кэшу.
По-умолчанию, запрос любого ключа из кэша автоматически использует текущую версию кэша для сайта. 
Однако, простейшие функции для работы с кэшем принимают аргумент version и вы можете указывать конкретную версию кэша.

[подробнее с сайта djbook](https://djbook.ru/rel1.9/topics/cache.html#cache-versioning)

[djangoproject](https://docs.djangoproject.com/en/2.2/topics/cache/#cache-versioning)
