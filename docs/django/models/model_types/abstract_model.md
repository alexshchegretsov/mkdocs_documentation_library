Абcтрактная модель
=



Абстрактные модели удобны при определении общих, для нескольких моделей, полей. 
Вы создаете базовую модель и добавляете abstract=True в класс Meta. 
Для этой модели не будет создана таблица в базе данных. Используя эту модель как родительскую для другой модели - 
все ее поля будут добавлены в таблицу в базе данных для этой модели. 
Нельзя использовать поля с одинаковыми названиями в дочерней и родительской моделях (Django вызовет исключение).


Абстрактные модели используются для хранения общих, для нескольких моделей, полей, 
а поскольку абстрактная модель - это питоновский абстрактный класс, то этот класс никак нельзя инстанциировать, 
т.е. создать экземпляр этого класса - тоесть запись в таблице. 
А если мы не сможем создавать записи в таблице - то и смысла в самой таблице нету.
А вот дочерние классы, для которых этот класс будет родительским, и которые унаследуют все общие поля абстрактного класса - могут, 
и таблицы будут создаваться по одной на каждый дочерний класс путём простого сложения 
полей абстрактной родительской модели и её дочерней, в отличии от multi-table(дословно многотабличность) моделей, 
где мы получаем разбиение таблицы на отдельную родительскую и отдельную дочернюю.

Используя атрибут related_name для ForeignKey или ManyToManyField, вы должны всегда определять уникальное название для обратной связи. 
Это одна из проблем абстрактных моделей, т.к. ее поля будут добавлены в каждой из дочерних моделей, 
с теми же значениями аргументов (включая related_name).

Для решения этой проблемы, добавляя related_name для абстрактной модели (и только для абстрактной), 
можно использовать в названии '%(app_label)s' и '%(class)s'.

```
from django.db import models
from django.contrib.auth.models import User


class BaseBlog(models.Model):
    # поля, общие для всего приложения
    # related_name - имя менеджера у класса User для доступа связанных с ним классов
    # возвращает QuerySet
    # что бы для дочерних классов не создавался один менеджер - используется подстановка
    # "%(app_label)s" - имя приложения, "%(class)s" - имя дочернего класса
    user = models.ForeignKey(User, related_name='%(app_label)s_related', null=True, on_delete=models.CASCADE)
    title = models.CharField(max_length=120)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)

    # делаем модель абстрактной
    # невидима для миграций
    class Meta:
        abstract = True

    def __str__(self):
        return self.title


class Bar(BaseBlog):
    bar_name = models.CharField(max_length=42)
    bar_age = models.IntegerField()


class Foo(models.Model):
    foo = models.CharField(max_length=42)

    def __str__(self):
        return self.foo    
```
